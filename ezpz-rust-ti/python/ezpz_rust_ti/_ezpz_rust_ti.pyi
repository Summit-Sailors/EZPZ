# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing
import builtins

import polars

class BasicTI:
  @staticmethod
  def mean_single(prices: polars.Series) -> builtins.float:
    r"""
    Calculate the arithmetic mean of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The arithmetic mean
    """
  @staticmethod
  def median_single(prices: polars.Series) -> builtins.float:
    r"""
    Calculate the median of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The median value
    """
  @staticmethod
  def mode_single(prices: polars.Series) -> builtins.float:
    r"""
    Calculate the mode of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The most frequently occurring value
    """
  @staticmethod
  def variance_single(prices: polars.Series) -> builtins.float:
    r"""
    Calculate the variance of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The variance
    """
  @staticmethod
  def standard_deviation_single(prices: polars.Series) -> builtins.float:
    r"""
    Calculate the standard deviation of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The standard deviation
    """
  @staticmethod
  def max_single(prices: polars.Series) -> builtins.float:
    r"""
    Find the maximum value.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The maximum value
    """
  @staticmethod
  def min_single(prices: polars.Series) -> builtins.float:
    r"""
    Find the minimum value.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    f64 - The minimum value
    """
  @staticmethod
  def absolute_deviation_single(prices: polars.Series, central_point: builtins.str) -> builtins.float:
    r"""
    Calculate the absolute deviation from a central point.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `central_point`: &str - Central point type ("mean", "median", etc.)

    # Returns
    f64 - The absolute deviation
    """
  @staticmethod
  def log_difference_single(price_t: builtins.float, price_t_1: builtins.float) -> builtins.float:
    r"""
    Calculate the logarithmic difference between two price points.

    # Parameters
    - `price_t`: f64 - Current price value
    - `price_t_1`: f64 - Previous price value

    # Returns
    f64 - The logarithmic difference
    """
  @staticmethod
  def mean_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate rolling mean over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size

    # Returns
    PySeriesStubbed - Series containing rolling mean values
    """
  @staticmethod
  def median_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate rolling median over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size

    # Returns
    PySeriesStubbed - Series containing rolling median values
    """
  @staticmethod
  def mode_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate rolling mode over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size

    # Returns
    PySeriesStubbed - Series containing rolling mode values
    """
  @staticmethod
  def variance_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate rolling variance over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size

    # Returns
    PySeriesStubbed - Series containing rolling variance values
    """
  @staticmethod
  def standard_deviation_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate rolling standard deviation over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size

    # Returns
    PySeriesStubbed - Series containing rolling standard deviation values
    """
  @staticmethod
  def absolute_deviation_bulk(prices: polars.Series, period: builtins.int, central_point: builtins.str) -> polars.Series:
    r"""
    Calculate rolling absolute deviation over a specified period.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values
    - `period`: usize - Rolling window size
    - `central_point`: &str - Central point type ("mean", "median", etc.)

    # Returns
    PySeriesStubbed - Series containing rolling absolute deviation values
    """
  @staticmethod
  def log_bulk(prices: polars.Series) -> polars.Series:
    r"""
    Calculate natural logarithm of all values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    PySeriesStubbed - Series containing natural logarithm values
    """
  @staticmethod
  def log_difference_bulk(prices: polars.Series) -> polars.Series:
    r"""
    Calculate logarithmic differences between consecutive values.

    # Parameters
    - `prices`: PySeriesStubbed - Series of numeric values

    # Returns
    PySeriesStubbed - Series containing logarithmic difference values
    """

class CandleTI:
  @staticmethod
  def moving_constant_envelopes_single(prices: polars.Series, constant_model_type: builtins.str, difference: builtins.float) -> polars.DataFrame:
    r"""
    Moving Constant Envelopes - Creates upper and lower bands from moving constant of price

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `constant_model_type`: &str - Type of moving average (e.g., "sma", "ema", "wma")
    - `difference`: f64 - Fixed difference value to create envelope bands

    # Returns
    DataFrame with columns:
    - `lower_envelope`: f64 - Lower envelope band (middle - difference)
    - `middle_envelope`: f64 - Middle line (moving average)
    - `upper_envelope`: f64 - Upper envelope band (middle + difference)
    """
  @staticmethod
  def mcginley_dynamic_envelopes_single(prices: polars.Series, difference: builtins.float, previous_mcginley_dynamic: builtins.float) -> polars.DataFrame:
    r"""
    McGinley Dynamic Envelopes - Variation of moving constant envelopes using McGinley Dynamic

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `difference`: f64 - Fixed difference value to create envelope bands
    - `previous_mcginley_dynamic`: f64 - Previous McGinley Dynamic value for calculation

    # Returns
    DataFrame with columns:
    - `lower_envelope`: f64 - Lower envelope band (McGinley Dynamic - difference)
    - `mcginley_dynamic`: f64 - McGinley Dynamic value
    - `upper_envelope`: f64 - Upper envelope band (McGinley Dynamic + difference)
    """
  @staticmethod
  def moving_constant_bands_single(
    prices: polars.Series, constant_model_type: builtins.str, deviation_model: builtins.str, deviation_multiplier: builtins.float
  ) -> polars.DataFrame:
    r"""
    Moving Constant Bands - Extended Bollinger Bands with configurable models

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `constant_model_type`: &str - Type of moving average for center line (e.g., "sma", "ema", "wma")
    - `deviation_model`: &str - Type of deviation calculation (e.g., "std", "mad")
    - `deviation_multiplier`: f64 - Multiplier for the deviation to create bands

    # Returns
    DataFrame with columns:
    - `lower_band`: f64 - Lower band (moving average - deviation * multiplier)
    - `middle_band`: f64 - Middle band (moving average)
    - `upper_band`: f64 - Upper band (moving average + deviation * multiplier)
    """
  @staticmethod
  def mcginley_dynamic_bands_single(
    prices: polars.Series, deviation_model: builtins.str, deviation_multiplier: builtins.float, previous_mcginley_dynamic: builtins.float
  ) -> polars.DataFrame:
    r"""
    McGinley Dynamic Bands - Variation of moving constant bands using McGinley Dynamic

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `deviation_model`: &str - Type of deviation calculation (e.g., "std", "mad")
    - `deviation_multiplier`: f64 - Multiplier for the deviation to create bands
    - `previous_mcginley_dynamic`: f64 - Previous McGinley Dynamic value for calculation

    # Returns
    DataFrame with columns:
    - `lower_band`: f64 - Lower band (McGinley Dynamic - deviation * multiplier)
    - `mcginley_dynamic`: f64 - McGinley Dynamic value
    - `upper_band`: f64 - Upper band (McGinley Dynamic + deviation * multiplier)
    """
  @staticmethod
  def ichimoku_cloud_single(
    highs: polars.Series, lows: polars.Series, close: polars.Series, conversion_period: builtins.int, base_period: builtins.int, span_b_period: builtins.int
  ) -> polars.DataFrame:
    r"""
    Ichimoku Cloud - Calculates support and resistance levels

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `conversion_period`: usize - Period for conversion line calculation (typically 9)
    - `base_period`: usize - Period for base line calculation (typically 26)
    - `span_b_period`: usize - Period for leading span B calculation (typically 52)

    # Returns
    DataFrame with columns:
    - `leading_span_a`: f64 - Leading Span A (future support/resistance)
    - `leading_span_b`: f64 - Leading Span B (future support/resistance)
    - `base_line`: f64 - Base Line (Kijun-sen)
    - `conversion_line`: f64 - Conversion Line (Tenkan-sen)
    - `lagged_price`: f64 - Lagging Span (Chikou Span)
    """
  @staticmethod
  def donchian_channels_single(highs: polars.Series, lows: polars.Series) -> polars.DataFrame:
    r"""
    Donchian Channels - Produces bands from period highs and lows

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices

    # Returns
    DataFrame with columns:
    - `donchian_lower`: f64 - Lower channel (lowest low over period)
    - `donchian_middle`: f64 - Middle channel (average of upper and lower)
    - `donchian_upper`: f64 - Upper channel (highest high over period)
    """
  @staticmethod
  def keltner_channel_single(
    highs: polars.Series,
    lows: polars.Series,
    close: polars.Series,
    constant_model_type: builtins.str,
    atr_constant_model_type: builtins.str,
    multiplier: builtins.float,
  ) -> polars.DataFrame:
    r"""
    Keltner Channel - Bands based on moving average and average true range

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of moving average for center line (e.g., "sma", "ema", "wma")
    - `atr_constant_model_type`: &str - Type of moving average for ATR calculation (e.g., "sma", "ema", "wma")
    - `multiplier`: f64 - Multiplier for the ATR to create channel width

    # Returns
    DataFrame with columns:
    - `keltner_lower`: f64 - Lower channel (moving average - ATR * multiplier)
    - `keltner_middle`: f64 - Middle channel (moving average)
    - `keltner_upper`: f64 - Upper channel (moving average + ATR * multiplier)
    """
  @staticmethod
  def supertrend_single(
    highs: polars.Series, lows: polars.Series, close: polars.Series, constant_model_type: builtins.str, multiplier: builtins.float
  ) -> polars.Series:
    r"""
    Supertrend - Trend indicator showing support and resistance levels

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of moving average for ATR calculation (e.g., "sma", "ema", "wma")
    - `multiplier`: f64 - Multiplier for the ATR to determine trend sensitivity

    # Returns
    Series containing:
    - `supertrend`: f64 - Supertrend value (support/resistance level based on trend direction)
    """
  @staticmethod
  def moving_constant_envelopes_bulk(
    prices: polars.Series, constant_model_type: builtins.str, difference: builtins.float, period: builtins.int
  ) -> polars.DataFrame:
    r"""
    Moving Constant Envelopes (Bulk) - Returns envelopes over time periods

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `constant_model_type`: &str - Type of moving average (e.g., "sma", "ema", "wma")
    - `difference`: f64 - Fixed difference value to create envelope bands
    - `period`: usize - Rolling window period for calculations

    # Returns
    DataFrame with columns:
    - `lower_envelope`: Vec<f64> - Time series of lower envelope bands
    - `middle_envelope`: Vec<f64> - Time series of middle lines (moving averages)
    - `upper_envelope`: Vec<f64> - Time series of upper envelope bands
    """
  @staticmethod
  def mcginley_dynamic_envelopes_bulk(
    prices: polars.Series, difference: builtins.float, previous_mcginley_dynamic: builtins.float, period: builtins.int
  ) -> polars.DataFrame:
    r"""
    McGinley Dynamic Envelopes (Bulk)

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `difference`: f64 - Fixed difference value to create envelope bands
    - `previous_mcginley_dynamic`: f64 - Initial McGinley Dynamic value for calculation
    - `period`: usize - Rolling window period for calculations

    # Returns
    DataFrame with columns:
    - `lower_envelope`: Vec<f64> - Time series of lower envelope bands
    - `mcginley_dynamic`: Vec<f64> - Time series of McGinley Dynamic values
    - `upper_envelope`: Vec<f64> - Time series of upper envelope bands
    """
  @staticmethod
  def moving_constant_bands_bulk(
    prices: polars.Series, constant_model_type: builtins.str, deviation_model: builtins.str, deviation_multiplier: builtins.float, period: builtins.int
  ) -> polars.DataFrame:
    r"""
    Moving Constant Bands (Bulk)

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `constant_model_type`: &str - Type of moving average for center line (e.g., "sma", "ema", "wma")
    - `deviation_model`: &str - Type of deviation calculation (e.g., "std", "mad")
    - `deviation_multiplier`: f64 - Multiplier for the deviation to create bands
    - `period`: usize - Rolling window period for calculations

    # Returns
    DataFrame with columns:
    - `lower_band`: Vec<f64> - Time series of lower bands
    - `middle_band`: Vec<f64> - Time series of middle bands (moving averages)
    - `upper_band`: Vec<f64> - Time series of upper bands
    """
  @staticmethod
  def mcginley_dynamic_bands_bulk(
    prices: polars.Series, deviation_model: builtins.str, deviation_multiplier: builtins.float, previous_mcginley_dynamic: builtins.float, period: builtins.int
  ) -> polars.DataFrame:
    r"""
    McGinley Dynamic Bands (Bulk)

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values
    - `deviation_model`: &str - Type of deviation calculation (e.g., "std", "mad")
    - `deviation_multiplier`: f64 - Multiplier for the deviation to create bands
    - `previous_mcginley_dynamic`: f64 - Initial McGinley Dynamic value for calculation
    - `period`: usize - Rolling window period for calculations

    # Returns
    DataFrame with columns:
    - `lower_band`: Vec<f64> - Time series of lower bands
    - `mcginley_dynamic`: Vec<f64> - Time series of McGinley Dynamic values
    - `upper_band`: Vec<f64> - Time series of upper bands
    """
  @staticmethod
  def ichimoku_cloud_bulk(
    highs: polars.Series, lows: polars.Series, closes: polars.Series, conversion_period: builtins.int, base_period: builtins.int, span_b_period: builtins.int
  ) -> polars.DataFrame:
    r"""
    Ichimoku Cloud (Bulk) - Returns ichimoku components over time

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `closes`: PySeriesStubbed - Series of closing prices
    - `conversion_period`: usize - Period for conversion line calculation (typically 9)
    - `base_period`: usize - Period for base line calculation (typically 26)
    - `span_b_period`: usize - Period for leading span B calculation (typically 52)

    # Returns
    DataFrame with columns:
    - `leading_span_a`: Vec<f64> - Time series of Leading Span A values
    - `leading_span_b`: Vec<f64> - Time series of Leading Span B values
    - `base_line`: Vec<f64> - Time series of Base Line (Kijun-sen) values
    - `conversion_line`: Vec<f64> - Time series of Conversion Line (Tenkan-sen) values
    - `lagged_price`: Vec<f64> - Time series of Lagging Span (Chikou Span) values
    """
  @staticmethod
  def donchian_channels_bulk(highs: polars.Series, lows: polars.Series, period: builtins.int) -> polars.DataFrame:
    r"""
    Donchian Channels (Bulk) - Returns donchian bands over time

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `period`: usize - Rolling window period for channel calculation

    # Returns
    DataFrame with columns:
    - `lower_band`: Vec<f64> - Time series of lower channels (lowest lows)
    - `middle_band`: Vec<f64> - Time series of middle channels (averages)
    - `upper_band`: Vec<f64> - Time series of upper channels (highest highs)
    """
  @staticmethod
  def keltner_channel_bulk(
    highs: polars.Series,
    lows: polars.Series,
    closes: polars.Series,
    constant_model_type: builtins.str,
    atr_constant_model_type: builtins.str,
    multiplier: builtins.float,
    period: builtins.int,
  ) -> polars.DataFrame:
    r"""
    Keltner Channel (Bulk) - Returns keltner bands over time

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `closes`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of moving average for center line (e.g., "sma", "ema", "wma")
    - `atr_constant_model_type`: &str - Type of moving average for ATR calculation (e.g., "sma", "ema", "wma")
    - `multiplier`: f64 - Multiplier for the ATR to create channel width
    - `period`: usize - Rolling window period for calculations

    # Returns
    DataFrame with columns:
    - `lower_band`: Vec<f64> - Time series of lower channels
    - `middle_band`: Vec<f64> - Time series of middle channels (moving averages)
    - `upper_band`: Vec<f64> - Time series of upper channels
    """
  @staticmethod
  def supertrend_bulk(
    highs: polars.Series, lows: polars.Series, closes: polars.Series, constant_model_type: builtins.str, multiplier: builtins.float, period: builtins.int
  ) -> polars.Series:
    r"""
    Supertrend (Bulk) - Returns supertrend values over time

    # Parameters
    - `highs`: PySeriesStubbed - Series of high prices
    - `lows`: PySeriesStubbed - Series of low prices
    - `closes`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of moving average for ATR calculation (e.g., "sma", "ema", "wma")
    - `multiplier`: f64 - Multiplier for the ATR to determine trend sensitivity
    - `period`: usize - Rolling window period for ATR calculation

    # Returns
    Series containing:
    - `supertrend`: Vec<f64> - Time series of supertrend values (support/resistance levels)
    """

class ChartTrendsTI:
  @staticmethod
  def peaks(prices: polars.Series, period: builtins.int, closest_neighbor: builtins.int) -> builtins.list[tuple[builtins.float, builtins.int]]:
    r"""
    Find peaks in a price series over a given period

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze
    - `period`: usize - Period length for peak detection
    - `closest_neighbor`: usize - Minimum distance between peaks

    # Returns
    Vec<(f64, usize)> - List of tuples containing:
    - `peak_value`: The price value at the peak
    - `peak_index`: The index position of the peak in the series
    """
  @staticmethod
  def valleys(prices: polars.Series, period: builtins.int, closest_neighbor: builtins.int) -> builtins.list[tuple[builtins.float, builtins.int]]:
    r"""
    Find valleys in a price series over a given period

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze
    - `period`: usize - Period length for valley detection
    - `closest_neighbor`: usize - Minimum distance between valleys

    # Returns
    Vec<(f64, usize)> - List of tuples containing:
    - `valley_value`: The price value at the valley
    - `valley_index`: The index position of the valley in the series
    """
  @staticmethod
  def peak_trend(prices: polars.Series, period: builtins.int) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculate peak trend (linear regression on peaks)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze
    - `period`: usize - Period length for peak detection

    # Returns
    Tuple of (slope: f64, intercept: f64)
    - `slope`: The slope of the linear regression line through peaks
    - `intercept`: The y-intercept of the linear regression line
    """
  @staticmethod
  def valley_trend(prices: polars.Series, period: builtins.int) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculate valley trend (linear regression on valleys)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze
    - `period`: usize - Period length for valley detection

    # Returns
    Tuple of (slope: f64, intercept: f64)
    - `slope`: The slope of the linear regression line through valleys
    - `intercept`: The y-intercept of the linear regression line
    """
  @staticmethod
  def overall_trend(prices: polars.Series) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculate overall trend (linear regression on all prices)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze

    # Returns
    Tuple of (slope: f64, intercept: f64)
    - `slope`: The slope of the linear regression line through all price points
    - `intercept`: The y-intercept of the linear regression line
    """
  @staticmethod
  def break_down_trends(
    prices: polars.Series,
    max_outliers: builtins.int,
    soft_r_squared_minimum: builtins.float,
    soft_r_squared_maximum: builtins.float,
    hard_r_squared_minimum: builtins.float,
    hard_r_squared_maximum: builtins.float,
    soft_standard_error_multiplier: builtins.float,
    hard_standard_error_multiplier: builtins.float,
    soft_reduced_chi_squared_multiplier: builtins.float,
    hard_reduced_chi_squared_multiplier: builtins.float,
  ) -> builtins.list[tuple[builtins.int, builtins.int, builtins.float, builtins.float]]:
    r"""
    Break down trends in a price series

    # Parameters
    - `prices`: PySeriesStubbed - Price series data to analyze
    - `max_outliers`: usize - Maximum number of outliers allowed
    - `soft_r_squared_minimum`: f64 - Soft minimum threshold for R-squared value
    - `soft_r_squared_maximum`: f64 - Soft maximum threshold for R-squared value
    - `hard_r_squared_minimum`: f64 - Hard minimum threshold for R-squared value
    - `hard_r_squared_maximum`: f64 - Hard maximum threshold for R-squared value
    - `soft_standard_error_multiplier`: f64 - Soft multiplier for standard error threshold
    - `hard_standard_error_multiplier`: f64 - Hard multiplier for standard error threshold
    - `soft_reduced_chi_squared_multiplier`: f64 - Soft multiplier for reduced chi-squared threshold
    - `hard_reduced_chi_squared_multiplier`: f64 - Hard multiplier for reduced chi-squared threshold

    # Returns
    Vec<(usize, usize, f64, f64)> - List of tuples containing:
    - `start_index`: Starting index of the trend segment
    - `end_index`: Ending index of the trend segment
    - `slope`: The slope of the linear regression for this trend segment
    - `intercept`: The y-intercept of the linear regression for this trend segment
    """

class CorrelationTI:
  @staticmethod
  def correlate_asset_prices_single(
    prices_asset_a: polars.Series, prices_asset_b: polars.Series, constant_model_type: builtins.str, deviation_model: builtins.str
  ) -> builtins.float:
    r"""
    Correlation between two assets - Single value calculation
    Calculates correlation between prices of two assets using specified models
    Returns a single correlation value for the entire price series

    # Parameters
    - `prices_asset_a`: PySeriesStubbed - Price series for the first asset
    - `prices_asset_b`: PySeriesStubbed - Price series for the second asset
    - `constant_model_type`: &str - Type of constant model to use for correlation calculation
    - `deviation_model`: &str - Type of deviation model to use for correlation calculation

    # Returns
    f64 - Single correlation coefficient between the two asset price series
    """
  @staticmethod
  def correlate_asset_prices_bulk(
    prices_asset_a: polars.Series, prices_asset_b: polars.Series, constant_model_type: builtins.str, deviation_model: builtins.str, period: builtins.int
  ) -> polars.Series:
    r"""
    Correlation between two assets - Rolling/Bulk calculation
    Calculates rolling correlation between prices of two assets using specified models
    Returns a series of correlation values for each period window

    # Parameters
    - `prices_asset_a`: PySeriesStubbed - Price series for the first asset
    - `prices_asset_b`: PySeriesStubbed - Price series for the second asset
    - `constant_model_type`: &str - Type of constant model to use for correlation calculation
    - `deviation_model`: &str - Type of deviation model to use for correlation calculation
    - `period`: usize - Rolling window size for correlation calculation

    # Returns
    PySeriesStubbed - Series containing rolling correlation coefficients for each period window
    """

class MATI:
  @staticmethod
  def moving_average_single(prices: polars.Series, moving_average_type: builtins.str) -> polars.Series:
    r"""
    Moving Average (Single) - Calculates a single moving average value for a series of prices

    # Arguments
    * `prices` - Series of price values
    * `moving_average_type` - Type of moving average ("simple", "exponential", "smoothed")

    # Returns
    Single moving average value as a Series
    """
  @staticmethod
  def moving_average_bulk(prices: polars.Series, moving_average_type: builtins.str, period: builtins.int) -> polars.Series:
    r"""
    Moving Average (Bulk) - Calculates moving averages over a rolling window

    # Arguments
    * `prices` - Series of price values
    * `moving_average_type` - Type of moving average ("simple", "exponential", "smoothed")
    * `period` - Period over which to calculate the moving average

    # Returns
    Series of moving average values
    """
  @staticmethod
  def mcginley_dynamic_single(latest_price: builtins.float, previous_mcginley_dynamic: builtins.float, period: builtins.int) -> polars.Series:
    r"""
    McGinley Dynamic (Single) - Calculates a single McGinley Dynamic value

    # Arguments
    * `latest_price` - Latest price value
    * `previous_mcginley_dynamic` - Previous McGinley Dynamic value (use 0.0 if none)
    * `period` - Period for calculation

    # Returns
    Single McGinley Dynamic value as a Series
    """
  @staticmethod
  def mcginley_dynamic_bulk(prices: polars.Series, previous_mcginley_dynamic: builtins.float, period: builtins.int) -> polars.Series:
    r"""
    McGinley Dynamic (Bulk) - Calculates McGinley Dynamic values over a series

    # Arguments
    * `prices` - Series of price values
    * `previous_mcginley_dynamic` - Previous McGinley Dynamic value (use 0.0 if none)
    * `period` - Period for calculation

    # Returns
    Series of McGinley Dynamic values
    """
  @staticmethod
  def personalised_moving_average_single(prices: polars.Series, alpha_nominator: builtins.float, alpha_denominator: builtins.float) -> polars.Series:
    r"""
    Personalised Moving Average (Single) - Calculates a single personalised moving average

    # Arguments
    * `prices` - Series of price values
    * `alpha_nominator` - Alpha nominator value
    * `alpha_denominator` - Alpha denominator value

    # Returns
    Single personalised moving average value as a Series
    """
  @staticmethod
  def personalised_moving_average_bulk(
    prices: polars.Series, alpha_nominator: builtins.float, alpha_denominator: builtins.float, period: builtins.int
  ) -> polars.Series:
    r"""
    Personalised Moving Average (Bulk) - Calculates personalised moving averages over a rolling window

    # Arguments
    * `prices` - Series of price values
    * `alpha_nominator` - Alpha nominator value
    * `alpha_denominator` - Alpha denominator value
    * `period` - Period over which to calculate the moving average

    # Returns
    Series of personalised moving average values
    """

class MomentumTI:
  r"""
  Momentum Technical Indicators - A collection of momentum analysis functions for financial data
  """
  @staticmethod
  def aroon_up_single(highs: polars.Series) -> builtins.float:
    r"""
    Aroon Up indicator

    Calculates the Aroon Up indicator, which measures the time since the highest high
    within a given period as a percentage.

    # Parameters
    * `highs` - PySeriesStubbed containing high price values

    # Returns
    * `PyResult<f64>` - The Aroon Up value (0-100), where higher values indicate recent highs
    """
  @staticmethod
  def aroon_down_single(lows: polars.Series) -> builtins.float:
    r"""
    Aroon Down indicator

    Calculates the Aroon Down indicator, which measures the time since the lowest low
    within a given period as a percentage.

    # Parameters
    * `lows` - PySeriesStubbed containing low price values

    # Returns
    * `PyResult<f64>` - The Aroon Down value (0-100), where higher values indicate recent lows
    """
  @staticmethod
  def aroon_oscillator_single(aroon_up: builtins.float, aroon_down: builtins.float) -> builtins.float:
    r"""
    Aroon Oscillator

    Calculates the Aroon Oscillator by subtracting Aroon Down from Aroon Up.
    Values range from -100 to +100, indicating trend strength and direction.

    # Parameters
    * `aroon_up` - f64 value of Aroon Up indicator (0-100)
    * `aroon_down` - f64 value of Aroon Down indicator (0-100)

    # Returns
    * `PyResult<f64>` - The Aroon Oscillator value (-100 to +100)
    """
  @staticmethod
  def aroon_indicator_single(highs: polars.Series, lows: polars.Series) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Aroon Indicator (complete calculation)

    Calculates all three Aroon components: Aroon Up, Aroon Down, and Aroon Oscillator
    in a single function call.

    # Parameters
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values

    # Returns
    * `PyResult<(f64, f64, f64)>` - Tuple containing (aroon_up, aroon_down, aroon_oscillator)
    """
  @staticmethod
  def long_parabolic_time_price_system_single(
    previous_sar: builtins.float, extreme_point: builtins.float, acceleration_factor: builtins.float, low: builtins.float
  ) -> builtins.float:
    r"""
    Long Parabolic Time Price System (Parabolic SAR for long positions)

    Calculates the Parabolic SAR (Stop and Reverse) for long positions, used to determine
    potential reversal points in price movement.

    # Parameters
    * `previous_sar` - f64 value of the previous SAR
    * `extreme_point` - f64 value of the extreme point (highest high for long positions)
    * `acceleration_factor` - f64 acceleration factor (typically starts at 0.02)
    * `low` - f64 current period's low price

    # Returns
    * `PyResult<f64>` - The calculated SAR value for long positions
    """
  @staticmethod
  def short_parabolic_time_price_system_single(
    previous_sar: builtins.float, extreme_point: builtins.float, acceleration_factor: builtins.float, high: builtins.float
  ) -> builtins.float:
    r"""
    Short Parabolic Time Price System (Parabolic SAR for short positions)

    Calculates the Parabolic SAR (Stop and Reverse) for short positions, used to determine
    potential reversal points in price movement.

    # Parameters
    * `previous_sar` - f64 value of the previous SAR
    * `extreme_point` - f64 value of the extreme point (lowest low for short positions)
    * `acceleration_factor` - f64 acceleration factor (typically starts at 0.02)
    * `high` - f64 current period's high price

    # Returns
    * `PyResult<f64>` - The calculated SAR value for short positions
    """
  @staticmethod
  def volume_price_trend_single(
    current_price: builtins.float, previous_price: builtins.float, volume: builtins.float, previous_volume_price_trend: builtins.float
  ) -> builtins.float:
    r"""
    Volume Price Trend

    Calculates the Volume Price Trend indicator, which combines price and volume
    to show the relationship between volume and price changes.

    # Parameters
    * `current_price` - f64 current period's price
    * `previous_price` - f64 previous period's price
    * `volume` - f64 current period's volume
    * `previous_volume_price_trend` - f64 previous VPT value

    # Returns
    * `PyResult<f64>` - The calculated Volume Price Trend value
    """
  @staticmethod
  def true_strength_index_single(
    prices: polars.Series, first_constant_model: builtins.str, first_period: builtins.int, second_constant_model: builtins.str
  ) -> builtins.float:
    r"""
    True Strength Index

    Calculates the True Strength Index, a momentum oscillator that uses price changes
    smoothed by two exponential moving averages.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `first_constant_model` - &str smoothing model for first smoothing ("sma", "ema", etc.)
    * `first_period` - usize period for first smoothing
    * `second_constant_model` - &str smoothing model for second smoothing ("sma", "ema", etc.)

    # Returns
    * `PyResult<f64>` - The True Strength Index value (typically ranges from -100 to +100)
    """
  @staticmethod
  def relative_strength_index_bulk(prices: polars.Series, constant_model_type: builtins.str, period: builtins.int) -> polars.Series:
    r"""
    Relative Strength Index (RSI) - bulk calculation

    Calculates RSI values for an entire series of prices. RSI measures the speed and change
    of price movements, oscillating between 0 and 100.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `constant_model_type` - &str smoothing model ("sma", "ema", etc.)
    * `period` - usize calculation period (commonly 14)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "rsi" containing RSI values (0-100)
    """
  @staticmethod
  def stochastic_oscillator_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Stochastic Oscillator - bulk calculation

    Calculates the Stochastic Oscillator, which compares a security's closing price
    to its price range over a given time period.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `period` - usize lookback period for calculation

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "stochastic" containing oscillator values (0-100)
    """
  @staticmethod
  def slow_stochastic_bulk(stochastics: polars.Series, constant_model_type: builtins.str, period: builtins.int) -> polars.Series:
    r"""
    Slow Stochastic - bulk calculation

    Calculates the Slow Stochastic by smoothing the regular Stochastic Oscillator
    to reduce noise and false signals.

    # Parameters
    * `stochastics` - PySeriesStubbed containing Stochastic Oscillator values
    * `constant_model_type` - &str smoothing model ("sma", "ema", etc.)
    * `period` - usize smoothing period

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "slow_stochastic" containing smoothed values (0-100)
    """
  @staticmethod
  def slowest_stochastic_bulk(slow_stochastics: polars.Series, constant_model_type: builtins.str, period: builtins.int) -> polars.Series:
    r"""
    Slowest Stochastic - bulk calculation

    Calculates the Slowest Stochastic by applying additional smoothing to the Slow Stochastic
    for even more noise reduction.

    # Parameters
    * `slow_stochastics` - PySeriesStubbed containing Slow Stochastic values
    * `constant_model_type` - &str smoothing model ("sma", "ema", etc.)
    * `period` - usize smoothing period

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "slowest_stochastic" containing double-smoothed values (0-100)
    """
  @staticmethod
  def williams_percent_r_bulk(high: polars.Series, low: polars.Series, close: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Williams %R - bulk calculation

    Calculates Williams %R, a momentum indicator that measures overbought and oversold levels.
    Values range from -100 to 0, where -20 and above indicates overbought, -80 and below indicates oversold.

    # Parameters
    * `high` - PySeriesStubbed containing high price values
    * `low` - PySeriesStubbed containing low price values
    * `close` - PySeriesStubbed containing closing price values
    * `period` - usize lookback period for calculation

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "williams_r" containing Williams %R values (-100 to 0)
    """
  @staticmethod
  def money_flow_index_bulk(prices: polars.Series, volume: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Money Flow Index - bulk calculation

    Calculates the Money Flow Index, a volume-weighted RSI that measures buying and selling pressure.
    Values range from 0 to 100, where >80 indicates overbought and <20 indicates oversold.

    # Parameters
    * `prices` - PySeriesStubbed containing typical price values ((high + low + close) / 3)
    * `volume` - PySeriesStubbed containing volume values
    * `period` - usize calculation period (commonly 14)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "mfi" containing Money Flow Index values (0-100)
    """
  @staticmethod
  def rate_of_change_bulk(prices: polars.Series) -> polars.Series:
    r"""
    Rate of Change - bulk calculation

    Calculates the Rate of Change, which measures the percentage change in price
    from one period to the next.

    # Parameters
    * `prices` - PySeriesStubbed containing price values

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "roc" containing rate of change values as percentages
    """
  @staticmethod
  def on_balance_volume_bulk(prices: polars.Series, volume: polars.Series, previous_obv: builtins.float) -> polars.Series:
    r"""
    On Balance Volume - bulk calculation

    Calculates On Balance Volume, a cumulative volume indicator that adds volume on up days
    and subtracts volume on down days to measure buying and selling pressure.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `volume` - PySeriesStubbed containing volume values
    * `previous_obv` - f64 starting OBV value (typically 0)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "obv" containing cumulative OBV values
    """
  @staticmethod
  def commodity_channel_index_bulk(
    prices: polars.Series, constant_model_type: builtins.str, deviation_model: builtins.str, constant_multiplier: builtins.float, period: builtins.int
  ) -> polars.Series:
    r"""
    Commodity Channel Index - bulk calculation

    Calculates the Commodity Channel Index, which measures the variation of a security's price
    from its statistical mean. Values typically range from -100 to +100.

    # Parameters
    * `prices` - PySeriesStubbed containing typical price values
    * `constant_model_type` - &str model for calculating moving average ("sma", "ema", etc.)
    * `deviation_model` - &str model for calculating deviation ("mad", "std", etc.)
    * `constant_multiplier` - f64 multiplier constant (typically 0.015)
    * `period` - usize calculation period (commonly 20)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "cci" containing CCI values
    """
  @staticmethod
  def mcginley_dynamic_commodity_channel_index_bulk(
    prices: polars.Series, previous_mcginley_dynamic: builtins.float, deviation_model: builtins.str, constant_multiplier: builtins.float, period: builtins.int
  ) -> tuple[polars.Series, polars.Series]:
    r"""
    McGinley Dynamic Commodity Channel Index - bulk calculation

    Calculates CCI using McGinley Dynamic as the moving average, which adapts to market conditions
    better than traditional moving averages.

    # Parameters
    * `prices` - PySeriesStubbed containing typical price values
    * `previous_mcginley_dynamic` - f64 initial McGinley Dynamic value
    * `deviation_model` - &str model for calculating deviation ("mad", "std", etc.)
    * `constant_multiplier` - f64 multiplier constant (typically 0.015)
    * `period` - usize calculation period

    # Returns
    * `PyResult<(PySeriesStubbed, PySeriesStubbed)>` - Tuple containing (CCI series, McGinley Dynamic series)
    """
  @staticmethod
  def macd_line_bulk(
    prices: polars.Series, short_period: builtins.int, short_period_model: builtins.str, long_period: builtins.int, long_period_model: builtins.str
  ) -> polars.Series:
    r"""
    MACD Line - bulk calculation

    Calculates the MACD (Moving Average Convergence Divergence) line by subtracting
    the long-period moving average from the short-period moving average.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `short_period` - usize period for short moving average (commonly 12)
    * `short_period_model` - &str model for short MA ("sma", "ema", etc.)
    * `long_period` - usize period for long moving average (commonly 26)
    * `long_period_model` - &str model for long MA ("sma", "ema", etc.)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "macd" containing MACD line values
    """
  @staticmethod
  def signal_line_bulk(macds: polars.Series, constant_model_type: builtins.str, period: builtins.int) -> polars.Series:
    r"""
    Signal Line - bulk calculation

    Calculates the MACD Signal Line by applying a moving average to the MACD line.
    Used to generate buy/sell signals when MACD crosses above or below the signal line.

    # Parameters
    * `macds` - PySeriesStubbed containing MACD line values
    * `constant_model_type` - &str smoothing model ("sma", "ema", etc.)
    * `period` - usize signal line period (commonly 9)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "signal" containing signal line values
    """
  @staticmethod
  def mcginley_dynamic_macd_line_bulk(
    prices: polars.Series,
    short_period: builtins.int,
    previous_short_mcginley: builtins.float,
    long_period: builtins.int,
    previous_long_mcginley: builtins.float,
  ) -> polars.DataFrame:
    r"""
    McGinley Dynamic MACD Line - bulk calculation

    Calculates MACD using McGinley Dynamic moving averages instead of traditional MAs,
    providing better adaptation to market volatility and reducing lag.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `short_period` - usize period for short McGinley Dynamic
    * `previous_short_mcginley` - f64 initial short McGinley Dynamic value
    * `long_period` - usize period for long McGinley Dynamic
    * `previous_long_mcginley` - f64 initial long McGinley Dynamic value

    # Returns
    * `PyResult<PyDfStubbed>` - DataFrame with columns: "macd", "short_mcginley", "long_mcginley"
    """
  @staticmethod
  def chaikin_oscillator_bulk(
    highs: polars.Series,
    lows: polars.Series,
    close: polars.Series,
    volume: polars.Series,
    short_period: builtins.int,
    long_period: builtins.int,
    previous_accumulation_distribution: builtins.float,
    short_period_model: builtins.str,
    long_period_model: builtins.str,
  ) -> tuple[polars.Series, polars.Series]:
    r"""
    Chaikin Oscillator - bulk calculation

    Calculates the Chaikin Oscillator, which applies MACD to the Accumulation/Distribution line
    to measure the momentum of the Accumulation/Distribution line.

    # Parameters
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values
    * `close` - PySeriesStubbed containing closing price values
    * `volume` - PySeriesStubbed containing volume values
    * `short_period` - usize short period for oscillator (commonly 3)
    * `long_period` - usize long period for oscillator (commonly 10)
    * `previous_accumulation_distribution` - f64 initial A/D line value
    * `short_period_model` - &str model for short MA ("sma", "ema", etc.)
    * `long_period_model` - &str model for long MA ("sma", "ema", etc.)

    # Returns
    * `PyResult<(PySeriesStubbed, PySeriesStubbed)>` - Tuple containing (Chaikin Oscillator, A/D Line)
    """
  @staticmethod
  def percentage_price_oscillator_bulk(
    prices: polars.Series, short_period: builtins.int, long_period: builtins.int, constant_model_type: builtins.str
  ) -> polars.Series:
    r"""
    Percentage Price Oscillator - bulk calculation

    Calculates the Percentage Price Oscillator, which is similar to MACD but expressed as a percentage.
    This makes it easier to compare securities with different price levels.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `short_period` - usize short period for moving average (commonly 12)
    * `long_period` - usize long period for moving average (commonly 26)
    * `constant_model_type` - &str model for moving averages ("sma", "ema", etc.)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "ppo" containing PPO values as percentages
    """
  @staticmethod
  def chande_momentum_oscillator_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Chande Momentum Oscillator - bulk calculation

    Calculates the Chande Momentum Oscillator, which measures momentum by calculating
    the difference between the sum of gains and losses over a given period.
    Values range from -100 to +100.

    # Parameters
    * `prices` - PySeriesStubbed containing price values
    * `period` - usize calculation period (commonly 14 or 20)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series named "chande_momentum_oscillator" containing CMO values (-100 to +100)
    """

class OtherTI:
  r"""
  Other Technical Indicators - A collection of other analysis functions for financial data
  """
  @staticmethod
  def return_on_investment_single(start_price: builtins.float, end_price: builtins.float, investment: builtins.float) -> tuple[builtins.float, builtins.float]:
    r"""
    Return on Investment - Calculates investment value and percentage change for a single period

    # Parameters
    - `start_price`: f64 - Initial price of the asset
    - `end_price`: f64 - Final price of the asset
    - `investment`: f64 - Initial investment amount

    # Returns
    Tuple of (final_investment_value: f64, percent_return: f64)
    - `final_investment_value`: The absolute value of the investment at the end
    - `percent_return`: The percentage return on the investment
    """
  @staticmethod
  def return_on_investment_bulk(prices: polars.Series, investment: builtins.float) -> tuple[polars.Series, polars.Series]:
    r"""
    Return on Investment Bulk - Calculates ROI for a series of consecutive price periods

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values (f64)
    - `investment`: f64 - Initial investment amount

    # Returns
    Tuple of (final_investment_values: PySeriesStubbed, percent_returns: PySeriesStubbed)
    - `final_investment_values`: Series of absolute investment values for each period
    - `percent_returns`: Series of percentage returns for each period
    """
  @staticmethod
  def true_range_single(close: builtins.float, high: builtins.float, low: builtins.float) -> builtins.float:
    r"""
    True Range - Calculates the greatest price movement for a single period

    # Parameters
    - `close`: f64 - Current period's closing price
    - `high`: f64 - Current period's highest price
    - `low`: f64 - Current period's lowest price

    # Returns
    f64 - The true range value (maximum of: high-low, |high-prev_close|, |low-prev_close|)
    """
  @staticmethod
  def true_range_bulk(close: polars.Series, high: polars.Series, low: polars.Series) -> polars.Series:
    r"""
    True Range Bulk - Calculates true range for a series of OHLC data

    # Parameters
    - `close`: PySeriesStubbed - Series of closing prices (f64)
    - `high`: PySeriesStubbed - Series of high prices (f64)
    - `low`: PySeriesStubbed - Series of low prices (f64)

    # Returns
    PySeriesStubbed - Series of true range values for each period
    """
  @staticmethod
  def average_true_range_single(close: polars.Series, high: polars.Series, low: polars.Series, constant_model_type: builtins.str) -> builtins.float:
    r"""
    Average True Range - Calculates the moving average of true range values for a single result

    # Parameters
    - `close`: PySeriesStubbed - Series of closing prices (f64)
    - `high`: PySeriesStubbed - Series of high prices (f64)
    - `low`: PySeriesStubbed - Series of low prices (f64)
    - `constant_model_type`: &str - Type of moving average ("sma", "ema", "wma", etc.)

    # Returns
    f64 - Single ATR value calculated from the entire price series
    """
  @staticmethod
  def average_true_range_bulk(
    close: polars.Series, high: polars.Series, low: polars.Series, constant_model_type: builtins.str, period: builtins.int
  ) -> polars.Series:
    r"""
    Average True Range Bulk - Calculates rolling ATR values over specified periods

    # Parameters
    - `close`: PySeriesStubbed - Series of closing prices (f64)
    - `high`: PySeriesStubbed - Series of high prices (f64)
    - `low`: PySeriesStubbed - Series of low prices (f64)
    - `constant_model_type`: &str - Type of moving average ("sma", "ema", "wma", etc.)
    - `period`: usize - Number of periods for the moving average calculation

    # Returns
    PySeriesStubbed - Series of ATR values for each period
    """
  @staticmethod
  def internal_bar_strength_single(high: builtins.float, low: builtins.float, close: builtins.float) -> builtins.float:
    r"""
    Internal Bar Strength - Calculates buy/sell oscillator based on close position within high-low range

    # Parameters
    - `high`: f64 - Period's highest price
    - `low`: f64 - Period's lowest price
    - `close`: f64 - Period's closing price

    # Returns
    f64 - IBS value between 0 and 1, where values closer to 1 indicate closes near the high,
          and values closer to 0 indicate closes near the low
    """
  @staticmethod
  def internal_bar_strength_bulk(high: polars.Series, low: polars.Series, close: polars.Series) -> polars.Series:
    r"""
    Internal Bar Strength Bulk - Calculates IBS for a series of OHLC data

    # Parameters
    - `high`: PySeriesStubbed - Series of high prices (f64)
    - `low`: PySeriesStubbed - Series of low prices (f64)
    - `close`: PySeriesStubbed - Series of closing prices (f64)

    # Returns
    PySeriesStubbed - Series of IBS values (0-1 range) for each period
    """
  @staticmethod
  def positivity_indicator(
    open: polars.Series, previous_close: polars.Series, signal_period: builtins.int, constant_model_type: builtins.str
  ) -> tuple[polars.Series, polars.Series]:
    r"""
    Positivity Indicator - Generates trading signals based on open vs previous close comparison

    # Parameters
    - `open`: PySeriesStubbed - Series of opening prices (f64)
    - `previous_close`: PySeriesStubbed - Series of previous period closing prices (f64)
    - `signal_period`: usize - Number of periods for signal line smoothing
    - `constant_model_type`: &str - Type of moving average for signal line ("sma", "ema", "wma", etc.)

    # Returns
    Tuple of (positivity_indicator: PySeriesStubbed, signal_line: PySeriesStubbed)
    - `positivity_indicator`: Series of raw positivity values based on open/close comparison
    - `signal_line`: Series of smoothed signal values using specified moving average
    """

class StandardTI:
  @staticmethod
  def sma_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Simple Moving Average - calculates the mean over a rolling window

    # Parameters
    - `prices`: PySeriesStubbed - Price series data
    - `period`: usize - Number of periods for the moving average window

    # Returns
    PySeriesStubbed - Series containing SMA values for each period
    """
  @staticmethod
  def smma_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Smoothed Moving Average - puts more weight on recent prices

    # Parameters
    - `prices`: PySeriesStubbed - Price series data
    - `period`: usize - Number of periods for the smoothed moving average window

    # Returns
    PySeriesStubbed - Series containing SMMA values for each period
    """
  @staticmethod
  def ema_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Exponential Moving Average - puts exponentially more weight on recent prices

    # Parameters
    - `prices`: PySeriesStubbed - Price series data
    - `period`: usize - Number of periods for the exponential moving average window

    # Returns
    PySeriesStubbed - Series containing EMA values for each period
    """
  @staticmethod
  def bollinger_bands_bulk(prices: polars.Series) -> polars.DataFrame:
    r"""
    Bollinger Bands - returns three series: lower band, middle (SMA), upper band
    Standard period is 20 with 2 standard deviations

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (minimum 20 periods required)

    # Returns
    PyDfStubbed - DataFrame with three columns:
    - `bb_lower`: Lower Bollinger Band values
    - `bb_middle`: Middle band (20-period SMA)
    - `bb_upper`: Upper Bollinger Band values
    """
  @staticmethod
  def macd_bulk(prices: polars.Series) -> polars.DataFrame:
    r"""
    MACD - Moving Average Convergence Divergence
    Returns three series: MACD line, Signal line, Histogram
    Standard periods: 12, 26, 9

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (minimum 34 periods required)

    # Returns
    PyDfStubbed - DataFrame with three columns:
    - `macd`: MACD line (12-period EMA - 26-period EMA)
    - `macd_signal`: Signal line (9-period EMA of MACD line)
    - `macd_histogram`: Histogram (MACD line - Signal line)
    """
  @staticmethod
  def rsi_bulk(prices: polars.Series) -> polars.Series:
    r"""
    RSI - Relative Strength Index
    Standard period is 14 using smoothed moving average

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (minimum 14 periods required)

    # Returns
    PySeriesStubbed - Series containing RSI values (0-100 scale)
    """
  @staticmethod
  def sma_single(prices: polars.Series) -> builtins.float:
    r"""
    Simple Moving Average - single value calculation

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (cannot be empty)

    # Returns
    f64 - Single SMA value calculated from all provided prices
    """
  @staticmethod
  def smma_single(prices: polars.Series) -> builtins.float:
    r"""
    Smoothed Moving Average - single value calculation

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (cannot be empty)

    # Returns
    f64 - Single SMMA value calculated from all provided prices
    """
  @staticmethod
  def ema_single(prices: polars.Series) -> builtins.float:
    r"""
    Exponential Moving Average - single value calculation

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (cannot be empty)

    # Returns
    f64 - Single EMA value calculated from all provided prices
    """
  @staticmethod
  def bollinger_bands_single(prices: polars.Series) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Bollinger Bands - single value calculation (requires exactly 20 periods)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (must be exactly 20 periods)

    # Returns
    Tuple of (lower_band: f64, middle_band: f64, upper_band: f64)
    - `lower_band`: Lower Bollinger Band value
    - `middle_band`: Middle band (SMA) value
    - `upper_band`: Upper Bollinger Band value
    """
  @staticmethod
  def macd_single(prices: polars.Series) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    MACD - single value calculation (requires exactly 34 periods)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (must be exactly 34 periods)

    # Returns
    Tuple of (macd_line: f64, signal_line: f64, histogram: f64)
    - `macd_line`: MACD line value (12-period EMA - 26-period EMA)
    - `signal_line`: Signal line value (9-period EMA of MACD line)
    - `histogram`: Histogram value (MACD line - Signal line)
    """
  @staticmethod
  def rsi_single(prices: polars.Series) -> builtins.float:
    r"""
    RSI - single value calculation (requires exactly 14 periods)

    # Parameters
    - `prices`: PySeriesStubbed - Price series data (must be exactly 14 periods)

    # Returns
    f64 - Single RSI value (0-100 scale)
    """

class StrengthTI:
  @staticmethod
  def accumulation_distribution(
    high: polars.Series, low: polars.Series, close: polars.Series, volume: polars.Series, previous_ad: builtins.float | None
  ) -> polars.Series:
    r"""
    Accumulation Distribution - Shows whether the stock is being accumulated or distributed

    # Parameters
    - `high`: PySeriesStubbed - Series of high prices
    - `low`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `volume`: PySeriesStubbed - Series of trading volumes
    - `previous_ad`: Option<f64> - Previous accumulation/distribution value (defaults to 0.0)

    # Returns
    PySeriesStubbed - Series containing accumulation/distribution values
    """
  @staticmethod
  def positive_volume_index(close: polars.Series, volume: polars.Series, previous_pvi: builtins.float | None) -> polars.Series:
    r"""
    Positive Volume Index - Measures volume trend strength when volume increases

    # Parameters
    - `close`: PySeriesStubbed - Series of closing prices
    - `volume`: PySeriesStubbed - Series of trading volumes
    - `previous_pvi`: Option<f64> - Previous positive volume index value (defaults to 0.0)

    # Returns
    PySeriesStubbed - Series containing positive volume index values
    """
  @staticmethod
  def negative_volume_index(close: polars.Series, volume: polars.Series, previous_nvi: builtins.float | None) -> polars.Series:
    r"""
    Negative Volume Index - Measures volume trend strength when volume decreases

    # Parameters
    - `close`: PySeriesStubbed - Series of closing prices
    - `volume`: PySeriesStubbed - Series of trading volumes
    - `previous_nvi`: Option<f64> - Previous negative volume index value (defaults to 0.0)

    # Returns
    PySeriesStubbed - Series containing negative volume index values
    """
  @staticmethod
  def relative_vigor_index(
    open: polars.Series, high: polars.Series, low: polars.Series, close: polars.Series, constant_model_type: builtins.str, period: builtins.int
  ) -> polars.Series:
    r"""
    Relative Vigor Index - Measures the strength of an asset by looking at previous prices

    # Parameters
    - `open`: PySeriesStubbed - Series of opening prices
    - `high`: PySeriesStubbed - Series of high prices
    - `low`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of constant model to use
    - `period`: usize - Period length for calculation

    # Returns
    PySeriesStubbed - Series containing relative vigor index values
    """
  @staticmethod
  def single_accumulation_distribution(
    high: builtins.float, low: builtins.float, close: builtins.float, volume: builtins.float, previous_ad: builtins.float | None
  ) -> builtins.float:
    r"""
    Single Accumulation Distribution - Single value calculation

    # Parameters
    - `high`: f64 - High price for the period
    - `low`: f64 - Low price for the period
    - `close`: f64 - Closing price for the period
    - `volume`: f64 - Trading volume for the period
    - `previous_ad`: Option<f64> - Previous accumulation/distribution value (defaults to 0.0)

    # Returns
    f64 - Single accumulation/distribution value
    """
  @staticmethod
  def single_volume_index(current_close: builtins.float, previous_close: builtins.float, previous_volume_index: builtins.float | None) -> builtins.float:
    r"""
    Single Volume Index - Generic version of PVI and NVI for single calculation

    # Parameters
    - `current_close`: f64 - Current period closing price
    - `previous_close`: f64 - Previous period closing price
    - `previous_volume_index`: Option<f64> - Previous volume index value (defaults to 0.0)

    # Returns
    f64 - Single volume index value
    """
  @staticmethod
  def single_relative_vigor_index(
    open: polars.Series, high: polars.Series, low: polars.Series, close: polars.Series, constant_model_type: builtins.str
  ) -> builtins.float:
    r"""
    Single Relative Vigor Index - Single value calculation

    # Parameters
    - `open`: PySeriesStubbed - Series of opening prices
    - `high`: PySeriesStubbed - Series of high prices
    - `low`: PySeriesStubbed - Series of low prices
    - `close`: PySeriesStubbed - Series of closing prices
    - `constant_model_type`: &str - Type of constant model to use

    # Returns
    f64 - Single relative vigor index value
    """

class TrendTI:
  r"""
  Trend Technical Indicators - A collection of trend analysis functions for financial data
  """
  @staticmethod
  def aroon_up_single(highs: polars.Series) -> builtins.float:
    r"""
    Calculate Aroon Up indicator for a single value

    The Aroon Up indicator measures the strength of upward price momentum by calculating
    the percentage of time since the highest high within the given period.

    # Arguments
    * `highs` - PySeriesStubbed containing high price values

    # Returns
    * `PyResult<f64>` - Aroon Up value (0-100), where higher values indicate stronger upward momentum

    # Errors
    * Returns PyValueError if highs series is empty
    """
  @staticmethod
  def aroon_down_single(lows: polars.Series) -> builtins.float:
    r"""
    Calculate Aroon Down indicator for a single value

    The Aroon Down indicator measures the strength of downward price momentum by calculating
    the percentage of time since the lowest low within the given period.

    # Arguments
    * `lows` - PySeriesStubbed containing low price values

    # Returns
    * `PyResult<f64>` - Aroon Down value (0-100), where higher values indicate stronger downward momentum

    # Errors
    * Returns PyValueError if lows series is empty
    """
  @staticmethod
  def aroon_oscillator_single(aroon_up: builtins.float, aroon_down: builtins.float) -> builtins.float:
    r"""
    Calculate Aroon Oscillator from Aroon Up and Aroon Down values

    The Aroon Oscillator is the difference between Aroon Up and Aroon Down indicators,
    providing a single measure of trend direction and strength.

    # Arguments
    * `aroon_up` - f64 value of Aroon Up indicator (0-100)
    * `aroon_down` - f64 value of Aroon Down indicator (0-100)

    # Returns
    * `PyResult<f64>` - Aroon Oscillator value (-100 to 100), where positive values indicate upward trend
    """
  @staticmethod
  def aroon_indicator_single(highs: polars.Series, lows: polars.Series) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Calculate complete Aroon Indicator (Up, Down, and Oscillator) for single values

    Computes all three Aroon components in one call: Aroon Up, Aroon Down, and Aroon Oscillator.

    # Arguments
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values

    # Returns
    * `PyResult<(f64, f64, f64)>` - Tuple containing (Aroon Up, Aroon Down, Aroon Oscillator)

    # Errors
    * Returns PyValueError if highs and lows series have different lengths
    """
  @staticmethod
  def long_parabolic_time_price_system_single(
    previous_sar: builtins.float, extreme_point: builtins.float, acceleration_factor: builtins.float, low: builtins.float
  ) -> builtins.float:
    r"""
    Calculate Parabolic SAR for long positions (single value)

    Computes the Stop and Reverse point for long positions in the Parabolic Time/Price System.

    # Arguments
    * `previous_sar` - f64 previous SAR value
    * `extreme_point` - f64 highest high reached during the current trend
    * `acceleration_factor` - f64 current acceleration factor (typically 0.02 to 0.20)
    * `low` - f64 current period's low price

    # Returns
    * `PyResult<f64>` - New SAR value for long position
    """
  @staticmethod
  def short_parabolic_time_price_system_single(
    previous_sar: builtins.float, extreme_point: builtins.float, acceleration_factor: builtins.float, high: builtins.float
  ) -> builtins.float:
    r"""
    Calculate Parabolic SAR for short positions (single value)

    Computes the Stop and Reverse point for short positions in the Parabolic Time/Price System.

    # Arguments
    * `previous_sar` - f64 previous SAR value
    * `extreme_point` - f64 lowest low reached during the current trend
    * `acceleration_factor` - f64 current acceleration factor (typically 0.02 to 0.20)
    * `high` - f64 current period's high price

    # Returns
    * `PyResult<f64>` - New SAR value for short position
    """
  @staticmethod
  def volume_price_trend_single(
    current_price: builtins.float, previous_price: builtins.float, volume: builtins.float, previous_volume_price_trend: builtins.float
  ) -> builtins.float:
    r"""
    Calculate Volume Price Trend indicator (single value)

    VPT combines price and volume to show the relationship between a security's price movement and volume.

    # Arguments
    * `current_price` - f64 current period's price
    * `previous_price` - f64 previous period's price
    * `volume` - f64 current period's volume
    * `previous_volume_price_trend` - f64 previous VPT value

    # Returns
    * `PyResult<f64>` - New Volume Price Trend value
    """
  @staticmethod
  def true_strength_index_single(
    prices: polars.Series, first_constant_model: builtins.str, first_period: builtins.int, second_constant_model: builtins.str
  ) -> builtins.float:
    r"""
    Calculate True Strength Index (single value)

    TSI is a momentum oscillator that uses moving averages of price changes to filter out price noise.

    # Arguments
    * `prices` - PySeriesStubbed containing price values
    * `first_constant_model` - &str smoothing method for first smoothing ("SimpleMovingAverage", "ExponentialMovingAverage", etc.)
    * `first_period` - usize period for first smoothing
    * `second_constant_model` - &str smoothing method for second smoothing

    # Returns
    * `PyResult<f64>` - True Strength Index value (-100 to 100)

    # Errors
    * Returns PyValueError if prices series is empty or invalid constant model type
    """
  @staticmethod
  def aroon_up_bulk(highs: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate Aroon Up indicator for time series data

    Computes Aroon Up values for each period in the time series, measuring upward momentum strength.

    # Arguments
    * `highs` - PySeriesStubbed containing high price values
    * `period` - usize lookback period for calculation (typically 14)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of Aroon Up values (0-100) named "aroon_up"
    """
  @staticmethod
  def aroon_down_bulk(lows: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Calculate Aroon Down indicator for time series data

    Computes Aroon Down values for each period in the time series, measuring downward momentum strength.

    # Arguments
    * `lows` - PySeriesStubbed containing low price values
    * `period` - usize lookback period for calculation (typically 14)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of Aroon Down values (0-100) named "aroon_down"
    """
  @staticmethod
  def aroon_oscillator_bulk(aroon_up: polars.Series, aroon_down: polars.Series) -> polars.Series:
    r"""
    Calculate Aroon Oscillator for time series data

    Computes the difference between Aroon Up and Aroon Down for each period.

    # Arguments
    * `aroon_up` - PySeriesStubbed containing Aroon Up values (0-100)
    * `aroon_down` - PySeriesStubbed containing Aroon Down values (0-100)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of Aroon Oscillator values (-100 to 100) named "aroon_oscillator"
    """
  @staticmethod
  def aroon_indicator_bulk(highs: polars.Series, lows: polars.Series, period: builtins.int) -> polars.DataFrame:
    r"""
    Calculate complete Aroon Indicator system for time series data

    Computes Aroon Up, Aroon Down, and Aroon Oscillator for each period in one operation.

    # Arguments
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values
    * `period` - usize lookback period for calculation (typically 14)

    # Returns
    * `PyResult<PyDfStubbed>` - DataFrame with columns: "aroon_up", "aroon_down", "aroon_oscillator"
    """
  @staticmethod
  def parabolic_time_price_system_bulk(
    highs: polars.Series,
    lows: polars.Series,
    acceleration_factor_start: builtins.float,
    acceleration_factor_max: builtins.float,
    acceleration_factor_step: builtins.float,
    start_position: builtins.str,
    previous_sar: builtins.float,
  ) -> polars.Series:
    r"""
    Calculate Parabolic Time Price System (SAR) for time series data

    Computes Stop and Reverse points for trend-following system that provides trailing stop levels.

    # Arguments
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values
    * `acceleration_factor_start` - f64 initial acceleration factor (typically 0.02)
    * `acceleration_factor_max` - f64 maximum acceleration factor (typically 0.20)
    * `acceleration_factor_step` - f64 acceleration factor increment (typically 0.02)
    * `start_position` - &str initial position: "Long" or "Short"
    * `previous_sar` - f64 initial SAR value

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of SAR values named "parabolic_sar"

    # Errors
    * Returns PyValueError if start_position is not "Long" or "Short"
    """
  @staticmethod
  def directional_movement_system_bulk(
    highs: polars.Series, lows: polars.Series, closes: polars.Series, period: builtins.int, constant_model_type: builtins.str
  ) -> polars.DataFrame:
    r"""
    Calculate Directional Movement System indicators for time series data

    Computes the complete DMS including Positive Directional Indicator (+DI), Negative Directional
    Indicator (-DI), Average Directional Index (ADX), and Average Directional Rating (ADXR).

    # Arguments
    * `highs` - PySeriesStubbed containing high price values
    * `lows` - PySeriesStubbed containing low price values
    * `closes` - PySeriesStubbed containing close price values
    * `period` - usize calculation period (typically 14)
    * `constant_model_type` - &str smoothing method: "SimpleMovingAverage", "SmoothedMovingAverage", "ExponentialMovingAverage", etc.

    # Returns
    * `PyResult<PyDfStubbed>` - DataFrame with columns: "positive_di", "negative_di", "adx", "adxr"

    # Errors
    * Returns PyValueError for invalid constant model type
    * Returns PyRuntimeError if DataFrame creation fails
    """
  @staticmethod
  def volume_price_trend_bulk(prices: polars.Series, volumes: polars.Series, previous_volume_price_trend: builtins.float) -> polars.Series:
    r"""
    Calculate Volume Price Trend indicator for time series data

    VPT combines price and volume to show the relationship between price movement and volume flow.

    # Arguments
    * `prices` - PySeriesStubbed containing price values
    * `volumes` - PySeriesStubbed containing volume values
    * `previous_volume_price_trend` - f64 initial VPT value (typically 0)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of Volume Price Trend values named "volume_price_trend"
    """
  @staticmethod
  def true_strength_index_bulk(
    prices: polars.Series, first_constant_model: builtins.str, first_period: builtins.int, second_constant_model: builtins.str, second_period: builtins.int
  ) -> polars.Series:
    r"""
    Calculate True Strength Index for time series data

    TSI is a momentum oscillator that uses double-smoothed price changes to filter noise
    and provide clearer signals of price momentum direction and strength.

    # Arguments
    * `prices` - PySeriesStubbed containing price values
    * `first_constant_model` - &str first smoothing method: "SimpleMovingAverage", "ExponentialMovingAverage", etc.
    * `first_period` - usize period for first smoothing (typically 25)
    * `second_constant_model` - &str second smoothing method
    * `second_period` - usize period for second smoothing (typically 13)

    # Returns
    * `PyResult<PySeriesStubbed>` - Series of TSI values (-100 to 100) named "true_strength_index"

    # Errors
    * Returns PyValueError for invalid constant model types
    """

class VolatilityTI:
  @staticmethod
  def ulcer_index_single(prices: polars.Series) -> builtins.float:
    r"""
    Ulcer Index (Single) - Calculates how quickly the price is able to get back to its former high
    Can be used instead of standard deviation for volatility measurement

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values to analyze

    # Returns
    f64 - Single Ulcer Index value representing overall price volatility and drawdown risk
    """
  @staticmethod
  def ulcer_index_bulk(prices: polars.Series, period: builtins.int) -> polars.Series:
    r"""
    Ulcer Index (Bulk) - Calculates rolling Ulcer Index over specified period
    Returns a series of Ulcer Index values

    # Parameters
    - `prices`: PySeriesStubbed - Series of price values to analyze
    - `period`: usize - Rolling window period for calculation

    # Returns
    PySeriesStubbed - Series of rolling Ulcer Index values with name "ulcer_index"
    """
  @staticmethod
  def volatility_system(
    high: polars.Series, low: polars.Series, close: polars.Series, period: builtins.int, constant_multiplier: builtins.float, constant_model_type: builtins.str
  ) -> polars.Series:
    r"""
    Volatility System - Calculates Welles volatility system with Stop and Reverse (SaR) points
    Uses trend analysis to determine long/short positions and calculate SaR levels
    Constant multiplier typically between 2.8-3.1 (Welles used 3.0)

    # Parameters
    - `high`: PySeriesStubbed - Series of high price values
    - `low`: PySeriesStubbed - Series of low price values
    - `close`: PySeriesStubbed - Series of closing price values
    - `period`: usize - Period for volatility calculation
    - `constant_multiplier`: f64 - Multiplier for volatility (typically 2.8-3.1)
    - `constant_model_type`: &str - Type of constant model to use for calculation

    # Returns
    PySeriesStubbed - Series of volatility system values with Stop and Reverse points, named "volatility_system"
    """

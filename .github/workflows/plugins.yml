name: EZPZ Plugin Management

on:
  push:
    branches: [main, develop]
    paths:
      - "plugins/**"
      - "ezpz.toml"
  pull_request:
    branches: [main]
    paths:
      - "plugins/**"
      - "ezpz.toml"

  workflow_dispatch:
    inputs:
      operation:
        description: "Operation to perform"
        required: true
        default: "test"
        type: choice
        options:
          - "test"
          - "register-and-update"
          - "publish"
          - "full-pipeline"
      dry_run:
        description: "Dry run (no actual registry changes)"
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: "3.13"
  RUST_VERSION: "1.87"

jobs:
  discover-plugins:
    runs-on: ubuntu-latest
    outputs:
      project-plugins: ${{ steps.analyze-plugins.outputs.project-plugins }}
      plugins-to-register: ${{ steps.analyze-plugins.outputs.plugins-to-register }}
      plugins-to-update: ${{ steps.analyze-plugins.outputs.plugins-to-update }}
      has-changes: ${{ steps.analyze-plugins.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Rye
        uses: eifinger/setup-rye@v4
        with:
          enable-cache: true

      - name: Install dependencies
        run: |
          rye sync

      - name: Refresh local registry
        run: |
          echo "Refreshing local registry from remote..."
          ezplugins refresh
          echo "Local registry refreshed successfully"

      - name: Analyze plugins and generate lists
        id: analyze-plugins
        run: |
          python << 'EOF'
          import json
          import toml
          import os
          import sys
          import importlib.util
          from pathlib import Path

          def load_ezpz_config():
              """Load ezpz.toml configuration"""
              try:
                  with open('ezpz.toml', 'r') as f:
                      config = toml.load(f)
                  return config.get('ezpz_pluginz', {})
              except FileNotFoundError:
                  print("‚ùå ezpz.toml not found")
                  sys.exit(1)

          def load_local_registry():
              """Load the local registry generated by ezplugins refresh"""
              registry_path = Path.home() / '.ezpz' / 'plugins.json'
              if not registry_path.exists():
                  print("‚ùå Local registry not found. Did ezplugins refresh run successfully?")
                  return {"plugins": []}
              
              with open(registry_path, 'r') as f:
                  return json.load(f)

          def extract_project_plugins(config):
              """Extract plugins from ezpz.toml include paths"""
              include_paths = config.get('include', [])
              project_plugins = []
              
              for path in include_paths:
                  if os.path.exists(path):
                      # Get the package name from the path or __init__.py
                      package_name = os.path.basename(path)
                      project_plugins.append({
                          'package_name': package_name,
                          'path': path
                      })
              
              return project_plugins

          def _load_plugin_from_file(file_path: Path):
            try:
              if not file_path.exists():
                return None

              # spec directly from file path
              spec = importlib.util.spec_from_file_location(f"plugin_{file_path.stem}", file_path)

              if spec is None or spec.loader is None:
                return None

              module = importlib.util.module_from_spec(spec)

              spec.loader.exec_module(module)

              if hasattr(module, "register_plugin"):
                register_func = module.register_plugin
                plugin_data = register_func()

                return PluginCreate(**plugin_data)
            except Exception as e:
              return None

          def _extract_package_name(plugin_dir_name: str) -> str:
            return plugin_dir_name.replace("-", "_")

          def _load_plugin_from_path(plugin_path: Path):
            try:
              entry_point_patterns = [
                # Pattern 1: python/package_name/__init__.py
                plugin_path / "python" / _extract_package_name(plugin_path.name) / "__init__.py",
                # Pattern 2: src/package_name/__init__.py
                plugin_path / "src" / _extract_package_name(plugin_path.name) / "__init__.py",
                # Pattern 3: package_name/__init__.py
                plugin_path / _extract_package_name(plugin_path.name) / "__init__.py",
                # Pattern 4: __init__.py in root
                plugin_path / "__init__.py",
              ]

              for entry_point_path in entry_point_patterns:
                if entry_point_path.exists():
                  print(f"üîç Trying entry point: {entry_point_path}")
                  plugin_info = _load_plugin_from_file(entry_point_path)
                  if plugin_info:
                    print(f"‚úÖ Successfully loaded plugin from {entry_point_path}")
                    return plugin_info

              # If no standard patterns work, search recursively for __init__.py files
              # that contain register_plugin function
              print(f"üîç Searching recursively in {plugin_path} for register_plugin function...")
              for init_file in plugin_path.rglob("__init__.py"):
                try:
                  with open(init_file, 'r') as f:
                    content = f.read()
                    if 'def register_plugin' in content:
                      print(f"üîç Found register_plugin in {init_file}")
                      plugin_info = _load_plugin_from_file(init_file)
                      if plugin_info:
                        print(f"‚úÖ Successfully loaded plugin from {init_file}")
                        return plugin_info
                except Exception as e:
                  print(f"‚ö†Ô∏è Error reading {init_file}: {e}")
                  continue

            except Exception as e:
              print(f"‚ùå Error loading plugin from {plugin_path}: {e}")

            return None

          def get_plugin_registration_info(plugin_path):
              """Get registration info by calling register_plugin() function"""
              plugin_path_obj = Path(plugin_path)

              logger.info(f"Searching for plugin in: {plugin_path_obj}")

              if plugin_path_obj.exists():
                plugin_info = _load_plugin_from_path(plugin_path_obj)
                if plugin_info:
                  return plugin_info

              return None

          def compare_plugins(project_plugin_info, registry_plugin):
              """Compare project plugin info with registry plugin to detect changes"""
              fields_to_compare = [
                  'version', 'description', 'author', 'category', 
                  'homepage', 'aliases', 'metadata_'
              ]
              
              for field in fields_to_compare:
                  project_value = project_plugin_info.get(field)
                  registry_value = registry_plugin.get(field)
                  
                  if project_value != registry_value:
                      print(f"üîÑ Difference found in {field}: {project_value} vs {registry_value}")
                      return True
              
              return False

          # Main analysis logic
          print("üîç Starting plugin analysis...")

          config = load_ezpz_config()
          local_registry = load_local_registry()

          # project plugins
          project_plugins = extract_project_plugins(config)
          print(f"üì¶ Found {len(project_plugins)} plugins in project")

          # lookup for registry plugins
          registry_plugins = {p['package_name']: p for p in local_registry.get('plugins', [])}

          plugins_to_register = []
          plugins_to_update = []

          for project_plugin in project_plugins:
              package_name = project_plugin['package_name']
              plugin_path = project_plugin['path']
              
              print(f"\nüìã Analyzing plugin: {package_name}")
              
              # Get registration info from the plugin
              registration_info = get_plugin_registration_info(plugin_path)
              if not registration_info:
                  print(f"‚ö†Ô∏è Skipping {package_name} - no registration info")
                  continue
              
              # if plugin exists in registry
              if package_name not in registry_plugins:
                  print(f"üÜï New plugin detected: {package_name}")
                  plugins_to_register.append({
                      'package_name': package_name,
                      'path': plugin_path,
                      'registration_info': registration_info
                  })
              else:
                  # with registry version
                  registry_plugin = registry_plugins[package_name]
                  if compare_plugins(registration_info, registry_plugin):
                      print(f"üîÑ Update needed for: {package_name}")
                      plugins_to_update.append({
                          'package_name': package_name,
                          'path': plugin_path,
                          'registration_info': registration_info,
                          'registry_info': registry_plugin
                      })
                  else:
                      print(f"‚úÖ No changes detected for: {package_name}")

          # Output results
          print(f"\nüìä Analysis Summary:")
          print(f"   - Plugins to register: {len(plugins_to_register)}")
          print(f"   - Plugins to update: {len(plugins_to_update)}")

          # GitHub outputs
          has_changes = len(plugins_to_register) > 0 or len(plugins_to_update) > 0

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"project-plugins={json.dumps(project_plugins)}\n")
              f.write(f"plugins-to-register={json.dumps(plugins_to_register)}\n")
              f.write(f"plugins-to-update={json.dumps(plugins_to_update)}\n")
              f.write(f"has-changes={str(has_changes).lower()}\n")

          print(f"\n‚úÖ Plugin analysis completed")
          EOF

  test-plugins:
    runs-on: ubuntu-latest
    needs: discover-plugins
    if: always() && needs.discover-plugins.outputs.has-changes == 'true'
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.discover-plugins.outputs.project-plugins) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Rust
        if: hashFiles(format('{0}/Cargo.toml', matrix.plugin.path)) != ''
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ env.RUST_VERSION }}
          default: true
          override: true

      - name: Install Rye
        uses: eifinger/setup-rye@v4
        with:
          enable-cache: true

      - name: Install dependencies
        run: |
          rye sync

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/uv
            ~/.cargo/registry
            ~/.cargo/git
            target/
          key: ${{ runner.os }}-${{ matrix.plugin.package_name }}-${{ hashFiles(format('{0}/**/pyproject.toml', matrix.plugin.path), format('{0}/**/Cargo.toml', matrix.plugin.path)) }}

      - name: Validate plugin structure
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          PACKAGE_NAME="${{ matrix.plugin.package_name }}"
          echo "üîç Validating plugin structure for: $PACKAGE_NAME"

          check_init_py() {
            local init_path="$1"
            if [ -f "$init_path" ]; then
              if grep -q "def register_plugin" "$init_path"; then
                echo "‚úÖ Found register_plugin function in $init_path"
                return 0
              else
                echo "‚ùå Missing register_plugin function in $init_path"
                return 1
              fi
            fi
            return 1
          }

          # Check for build configuration files
          HAS_PYPROJECT=false
          HAS_CARGO=false

          if [ -f "$PLUGIN_PATH/pyproject.toml" ]; then
            HAS_PYPROJECT=true
            echo "‚úÖ Found pyproject.toml"
          fi

          if [ -f "$PLUGIN_PATH/Cargo.toml" ]; then
            HAS_CARGO=true
            echo "‚úÖ Found Cargo.toml"
          fi

          if [ "$HAS_PYPROJECT" = false ] && [ "$HAS_CARGO" = false ]; then
            echo "‚ùå Missing both pyproject.toml and Cargo.toml in $PLUGIN_PATH"
            exit 1
          fi

          INIT_FOUND=false

          # Pattern 1: python/package_name/__init__.py
          if check_init_py "$PLUGIN_PATH/python/$PACKAGE_NAME/__init__.py"; then
            INIT_FOUND=true
          # Pattern 2: src/package_name/__init__.py
          elif check_init_py "$PLUGIN_PATH/src/$PACKAGE_NAME/__init__.py"; then
            INIT_FOUND=true
          # Pattern 3: package_name/__init__.py
          elif check_init_py "$PLUGIN_PATH/$PACKAGE_NAME/__init__.py"; then
            INIT_FOUND=true
          # Pattern 4: __init__.py in root
          elif check_init_py "$PLUGIN_PATH/__init__.py"; then
            INIT_FOUND=true
          else
            # recursively search for any __init__.py with register_plugin
            echo "üîç Searching recursively for __init__.py with register_plugin..."
            FOUND_INIT=$(find "$PLUGIN_PATH" -name "__init__.py" -exec grep -l "def register_plugin" {} \; 2>/dev/null | head -1)
            if [ -n "$FOUND_INIT" ]; then
              echo "‚úÖ Found register_plugin function in $FOUND_INIT"
              INIT_FOUND=true
            fi
          fi

          if [ "$INIT_FOUND" = false ]; then
            echo "‚ùå Could not find __init__.py with register_plugin function in any expected location"
            exit 1
          fi

          TESTS_FOUND=false
          if [ -d "$PLUGIN_PATH/tests" ]; then
            TESTS_FOUND=true
            echo "‚úÖ Found tests directory"
          elif [ -d "$PLUGIN_PATH/python/tests" ]; then
            TESTS_FOUND=true
            echo "‚úÖ Found tests directory in python/"
          elif [ -d "$PLUGIN_PATH/src/tests" ]; then
            TESTS_FOUND=true
            echo "‚úÖ Found tests directory in src/"
          fi

          if [ "$TESTS_FOUND" = false ]; then
            echo "‚ùå Missing tests directory in expected locations"
            exit 1
          fi

          # Additional validation for Rust projects
          if [ "$HAS_CARGO" = true ]; then
            if [ ! -f "$PLUGIN_PATH/src/lib.rs" ] && [ ! -f "$PLUGIN_PATH/src/main.rs" ]; then
              echo "‚ùå Rust project missing src/lib.rs or src/main.rs"
              exit 1
            else
              echo "‚úÖ Found Rust source files"
            fi
          fi

          # Validate Python package structure for hybrid projects
          if [ "$HAS_PYPROJECT" = true ] && [ -d "$PLUGIN_PATH/python" ]; then
            echo "‚úÖ Detected hybrid Python/Rust project structure"
            
            # Check for py.typed file (for type hints)
            if [ -f "$PLUGIN_PATH/python/$PACKAGE_NAME/py.typed" ]; then
              echo "‚úÖ Found py.typed for type hints"
            fi
            
            # Check for stub files (.pyi)
            if find "$PLUGIN_PATH/python/$PACKAGE_NAME" -name "*.pyi" -type f | grep -q .; then
              echo "‚úÖ Found Python stub files"
            fi
          fi

          echo "‚úÖ Plugin structure validation passed"

      - name: Install plugin dependencies
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"

          rye sync

      - name: Build Rust components
        if: hashFiles(format('{0}/Cargo.toml', matrix.plugin.path)) != ''
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          cd "$PLUGIN_PATH"
          cargo build --release
          cd -

      - name: Run plugin tests
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          echo "üß™ Running tests for ${{ matrix.plugin.package_name }}"

          # Run Python tests
          if [ -d "$PLUGIN_PATH/tests" ]; then
            echo "Running Python tests..."
            rye test -p "$PLUGIN_PATH"
          fi

          # Run Rust tests
          if [ -f "$PLUGIN_PATH/Cargo.toml" ]; then
            echo "Running Rust tests..."
            cd "$PLUGIN_PATH"
            cargo test
            cd -
          fi

  register-update-plugins:
    runs-on: ubuntu-latest
    needs: [discover-plugins, test-plugins]
    if: |
      always() && 
      needs.discover-plugins.outputs.has-changes == 'true' &&
      (needs.test-plugins.result == 'success' || needs.test-plugins.result == 'skipped') &&
      (github.event.inputs.operation == 'register-and-update' || github.event.inputs.operation == 'full-pipeline')
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Rye
        uses: eifinger/setup-rye@v4
        with:
          enable-cache: true

      - name: Install dependencies
        run: |
          rye sync

      - name: Refresh local registry
        run: |
          ezplugins refresh

      - name: Register new plugins
        if: needs.discover-plugins.outputs.plugins-to-register != '[]'
        env:
          REGISTRY_API_KEY: ${{ secrets.REGISTRY_API_KEY }}
        run: |
          echo "üÜï Registering new plugins..."

          PLUGINS_TO_REGISTER='${{ needs.discover-plugins.outputs.plugins-to-register }}'

          python << EOF
          import json
          import subprocess
          import os

          plugins = json.loads('''$PLUGINS_TO_REGISTER''')

          for plugin in plugins:
              package_name = plugin['package_name']
              plugin_path = plugin['path']
              
              print(f"üìù Registering plugin: {package_name}")
              
              try:
                  if "${{ github.event.inputs.dry_run }}" == "true":
                      print(f"üèÉ DRY RUN: Would register {package_name} from {plugin_path}")
                  else:
                      result = subprocess.run([
                          'rye', 'run', 'ezplugins', 'register', plugin_path
                      ], capture_output=True, text=True, check=True)
                      print(f"‚úÖ Successfully registered {package_name}")
                      print(result.stdout)
              except subprocess.CalledProcessError as e:
                  print(f"‚ùå Failed to register {package_name}: {e}")
                  print(f"stdout: {e.stdout}")
                  print(f"stderr: {e.stderr}")
                  continue
          EOF

      - name: Update existing plugins
        if: needs.discover-plugins.outputs.plugins-to-update != '[]'
        env:
          REGISTRY_API_KEY: ${{ secrets.REGISTRY_API_KEY }}
        run: |
          echo "üîÑ Updating existing plugins..."

          PLUGINS_TO_UPDATE='${{ needs.discover-plugins.outputs.plugins-to-update }}'

          python << EOF
          import json
          import subprocess
          import os

          plugins = json.loads('''$PLUGINS_TO_UPDATE''')

          for plugin in plugins:
              package_name = plugin['package_name']
              plugin_path = plugin['path']
              plugin_name = plugin['registration_info']['name']
              
              print(f"üîÑ Updating plugin: {package_name} ({plugin_name})")
              
              try:
                  if "${{ github.event.inputs.dry_run }}" == "true":
                      print(f"üèÉ DRY RUN: Would update {plugin_name} from {plugin_path}")
                  else:
                      result = subprocess.run([
                          'rye', 'run', 'ezplugins', 'update', plugin_name, plugin_path
                      ], capture_output=True, text=True, check=True)
                      print(f"‚úÖ Successfully updated {package_name}")
                      print(result.stdout)
              except subprocess.CalledProcessError as e:
                  print(f"‚ùå Failed to update {package_name}: {e}")
                  print(f"stdout: {e.stdout}")
                  print(f"stderr: {e.stderr}")
                  continue
          EOF

  publish-plugins:
    runs-on: ubuntu-latest
    needs: [discover-plugins, test-plugins, register-update-plugins]
    if: |
      always() && 
      needs.discover-plugins.outputs.has-changes == 'true' &&
      (needs.test-plugins.result == 'success' || needs.test-plugins.result == 'skipped') &&
      (needs.register-update-plugins.result == 'success' || needs.register-update-plugins.result == 'skipped') &&
      (github.event.inputs.operation == 'publish' || github.event.inputs.operation == 'full-pipeline')
    strategy:
      matrix:
        plugin: ${{ fromJson(needs.discover-plugins.outputs.project-plugins) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Rust
        if: hashFiles(format('{0}/Cargo.toml', matrix.plugin.path)) != ''
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ env.RUST_VERSION }}
          default: true
          override: true

      - name: Install Rye
        uses: eifinger/setup-rye@v4
        with:
          enable-cache: true

      - name: Install build dependencies
        run: |
          rye sync
          rye add twine

      - name: Check if plugin needs publishing
        id: check-publish
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          PACKAGE_NAME="${{ matrix.plugin.package_name }}"

          PLUGINS_TO_REGISTER='${{ needs.discover-plugins.outputs.plugins-to-register }}'
          PLUGINS_TO_UPDATE='${{ needs.discover-plugins.outputs.plugins-to-update }}'

          python << EOF
          import json
          import os

          plugins_to_register = json.loads('''$PLUGINS_TO_REGISTER''')
          plugins_to_update = json.loads('''$PLUGINS_TO_UPDATE''')

          package_name = '$PACKAGE_NAME'

          needs_publishing = False
          publish_type = 'none'

          # always publish new plugins
          for plugin in plugins_to_register:
              if plugin['package_name'] == package_name:
                  needs_publishing = True
                  publish_type = 'new'
                  break

          # publish only if significant changes
          if not needs_publishing:
              for plugin in plugins_to_update:
                  if plugin['package_name'] == package_name:
                      # For updates, we assume if it made it to the update list,
                      # it has significant changes worth publishing
                      needs_publishing = True
                      publish_type = 'update'
                      break

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"needs-publishing={str(needs_publishing).lower()}\n")
              f.write(f"publish-type={publish_type}\n")

          print(f"Plugin {package_name} needs publishing: {needs_publishing} (type: {publish_type})")
          EOF

      - name: Build plugin
        if: steps.check-publish.outputs.needs-publishing == 'true'
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          cd "$PLUGIN_PATH"

          echo "üèóÔ∏è Building plugin: ${{ matrix.plugin.package_name }}"

          # Build Python package
          if [ -f "pyproject.toml" ]; then
            echo "üì¶ Building Python package..."
            rye build
          fi

          # Build Rust package
          if [ -f "Cargo.toml" ]; then
            echo "ü¶Ä Building Rust package..."
            cargo build --release
          fi

          cd -

      - name: Validate package
        if: steps.check-publish.outputs.needs-publishing == 'true'
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"

          if [ -d "$PLUGIN_PATH/dist" ]; then
            echo "üîç Validating package..."
            twine check "$PLUGIN_PATH/dist/*"
          fi

      - name: Publish to PyPI
        if: steps.check-publish.outputs.needs-publishing == 'true' && github.event.inputs.dry_run != 'true'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"

          echo "üöÄ Publishing ${{ matrix.plugin.package_name }} to PyPI..."

          if [ -d "$PLUGIN_PATH/dist" ] && [ "$(ls -A $PLUGIN_PATH/dist)" ]; then
            twine upload "$PLUGIN_PATH/dist/*"
            echo "‚úÖ Successfully published ${{ matrix.plugin.package_name }} to PyPI"
          else
            echo "‚ö†Ô∏è No distribution files found for ${{ matrix.plugin.package_name }}"
          fi

      - name: Publish Rust crate
        if: steps.check-publish.outputs.needs-publishing == 'true' && hashFiles(format('{0}/Cargo.toml', matrix.plugin.path)) != '' && github.event.inputs.dry_run != 'true'
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_TOKEN }}
        run: |
          PLUGIN_PATH="${{ matrix.plugin.path }}"
          cd "$PLUGIN_PATH"

          echo "ü¶Ä Publishing ${{ matrix.plugin.package_name }} to crates.io..."

          if [ -f "Cargo.toml" ]; then
            cargo publish
            echo "‚úÖ Successfully published ${{ matrix.plugin.package_name }} to crates.io"
          fi

          cd -

  generate-report:
    runs-on: ubuntu-latest
    needs:
      [discover-plugins, test-plugins, register-update-plugins, publish-plugins]
    if: always()
    steps:
      - name: Generate workflow report
        run: |
          echo "# üìä EZPZ Plugin Workflow Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Workflow Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Operation**: ${{ github.event.inputs.operation || 'automatic' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run**: ${{ github.event.inputs.dry_run || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Plugin Discovery Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.discover-plugins.result }}" = "success" ]; then
            echo "‚úÖ **Plugin Discovery**: Success" >> $GITHUB_STEP_SUMMARY
            echo "- **Has Changes**: ${{ needs.discover-plugins.outputs.has-changes }}" >> $GITHUB_STEP_SUMMARY
            
            PLUGINS_TO_REGISTER='${{ needs.discover-plugins.outputs.plugins-to-register }}'
            PLUGINS_TO_UPDATE='${{ needs.discover-plugins.outputs.plugins-to-update }}'
            
            # Count plugins
            REG_COUNT=$(echo "$PLUGINS_TO_REGISTER" | python -c "import json, sys; print(len(json.loads(sys.stdin.read())))")
            UPD_COUNT=$(echo "$PLUGINS_TO_UPDATE" | python -c "import json, sys; print(len(json.loads(sys.stdin.read())))")
            
            echo "- **Plugins to Register**: $REG_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Plugins to Update**: $UPD_COUNT" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Plugin Discovery**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Test Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.test-plugins.result }}" = "success" ]; then
            echo "‚úÖ **Plugin Tests**: All tests passed" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.test-plugins.result }}" = "skipped" ]; then
            echo "‚è≠Ô∏è **Plugin Tests**: Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Plugin Tests**: Some tests failed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Registration and Updates" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.register-update-plugins.result }}" = "success" ]; then
            echo "‚úÖ **Registry Operations**: Success" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.register-update-plugins.result }}" = "skipped" ]; then
            echo "‚è≠Ô∏è **Registry Operations**: Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Registry Operations**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Publishing Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.publish-plugins.result }}" = "success" ]; then
            echo "‚úÖ **Publishing**: Success" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.publish-plugins.result }}" = "skipped" ]; then
            echo "‚è≠Ô∏è **Publishing**: Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Publishing**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Overall Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.discover-plugins.result }}" = "success" ] && \
             [ "${{ needs.test-plugins.result }}" != "failure" ] && \
             [ "${{ needs.register-update-plugins.result }}" != "failure" ] && \
             [ "${{ needs.publish-plugins.result }}" != "failure" ]; then
            echo "üéâ **Workflow completed successfully!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **Workflow completed with issues. Check individual job results.**" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Report generated at $(date)*" >> $GITHUB_STEP_SUMMARY
